% \iffalse meta-comment
% !TEX program  = pdfLaTeX
%<*internal> 
\iffalse
%</internal> 
%<*readme> 
----------------------------------------------------------------
##### oops --- A tool for encoding mathematical notation
##### mathematical notation
- Source repository: https://github.com/rogard/oops
- Released under the LaTeX Project Public License v1.3c or later
- See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

%</readme> 
%<*internal> 
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
\expandafter\begingroup
\fi
%</internal> 
%<*install> 
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------------------
oops --- A tool for encoding mathematical notation
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2020 by Erwann Rogard

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Erwann Rogard.

This work consists of the file oops.dtx and the derived files:
oops.sty, oops.pdf, ...

\endpostamble
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install> 
%<install> \endbatchfile
%<*internal> 
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
\expandafter\endbatchfile
\else
\expandafter\endgroup
\fi
%</internal> 
%<package> \RequirePackage{datetime}
%<package> \RequirePackage{l3keys2e}
%<package> \RequirePackage{xparse}[2019/05/28]
%<package> \ProvidesExplPackage
%<package> {oops}                                                                                       % Package name
%<package> {2020/04/06}                                                                                 % Release date
%<package> {1.3}                                                                                        % Release version
%<package> {A tool for encoding mathematical notation}    % Description
% 
%<*driver> 
\documentclass[full]{l3doc}
\usepackage{oops}
\usepackage{amsmath, amssymb}
\usepackage{bookmark}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\usepackage{fvextra}
\usepackage{pdfpages}
\usepackage{tabto}
\usepackage{tcolorbox}
\tcbuselibrary{listings, breakable}
\ExplSyntaxOn
\tl_gset:Nn \partname {Part}
\ExplSyntaxOff
\EnableCrossrefs
\CodelineIndex
\RecordChanges
% ^^A\AtEndDocument { \PrintChanges \PrintIndex }
\ExplSyntaxOn
\providecommand\docargnoval{\c_novalue_tl}
\providecommand\docbool{boolean}
\providecommand\docconcept[1]{\textit{#1}}
\providecommand\docdefaultfor{default~for~}
\providecommand\docenvdoc{\env{document}}
\providecommand\docenvpreamb{preamble}
\providecommand\doceval[1]{\texttt{\char`\{}#1\texttt{\char`\}}}
\providecommand\dockvl{keyval~list}
\providecommand\docwarninp{\item[Input:~]}
\providecommand\docwarnsymp{\item[Symptom:~]}
\providecommand\docwarnfix{\item[Workaround:~]}
\providecommand\docwarnsee{\item[See:~]}
\providecommand\docassign[2]{#1~$\leftarrow$~#2}
\providecommand\doclist[1]{Listing~\autoref{listing:#1}}
\providecommand\docopto[1]{\texttt{[}#1\texttt{]}}
\providecommand\docopte[2]{\texttt{#1}\doceval{#2}}
\providecommand\docoptd[1]{\texttt{\textless}#1\texttt{\textgreater}}
\providecommand\docarg[1]{\texttt{#1}} % fun[param] (macro) vs fun[arg] (eval)
\providecommand\docpath{path}
\cs_new:Nn \__erw_docu:n{\MakeUppercase #1}
\providecommand\docU[1]{\exp_args:Nx \__erw_docu:n{#1}}
\providecommand\doctl{token~list}
\providecommand\docvers[2]{v#1.#2}
\providecommand\docwarn{\noindent\textbf{Warning}:~}
\providecommand\pkgpardefi{keyval~list$_{1}$}
\providecommand\pkgpardefii{keyval~list$_{2}$} %^^A deprecated
\providecommand\pkgparhead{token~list$_{2}$}
\providecommand\pkgparinneri{code$_{1}$}
\providecommand\pkgparinnerii{code$_{3}$} %^^A deprecated
\providecommand\pkgparname{token~list$_{1}$}
\providecommand\pkgparnamedefault{\docarg{Math}}
\providecommand\pkgparouter{code$_{2}$}
\providecommand\pkgpars{\Arg{\pkgparsi}\Arg{\pkgparsii}\Arg{\pkgparsiii}}
\providecommand\pkgparsi{token~list$_{3}$}
\providecommand\pkgparsii{token~list$_{4}$}
\providecommand\pkgparsiii{token~list$_{5}$}
\providecommand\pkgpartail{token~list$_{6}$} %^^A deprecated
\providecommand\pkgkeyin{\docarg{Inner}}
\providecommand\pkgkeyna{\docarg{Name}}
\providecommand\pkgkeyou{\docarg{Outer}}
\providecommand\pkgkeywr{\docarg{Write}}
\providecommand\pkgkeyse{\docarg{Separ}}
\providecommand\pkgobj[1]{object identified by #1}
\providecommand\pkgoptions{kvl0}
\providecommand\pkgsep[1]{\Arg{#1}}
\providecommand\pkgwrite{\cs{Oops}\docarg{\meta{\pkgparname}}\docopte{i}{\meta{\pkgparinneri}}\Arg{\pkgpardefi}}
\ExplSyntaxOff
\begin{document}
\DocInput{\jobname.dtx}
\end{document}
%</driver> 
% \fi
% 
% \GetFileInfo{\jobname.sty}
% 
% \title{^^A
% \pkg{oops}, an object oriented practical scribe's package.\thanks{^^A
% This file describes version \fileversion, last revised \filedate.^^A
% }^^A
% }
%   \author{Erwann Rogard\thanks{firstname dot lastname AusTria gmail dot com}}
%   
%   \date{Released \filedate}
%   
%   \maketitle
%   
%   \begin{abstract}\pkg{oops}~is a package for \LaTeX~(hence ``scribe'') for generating macro definitions as the need
%     arises in the document, and to organize them along two dimensions: functions and objects, hence ``OO''.
%     This is done using a minimalist interface built upon \pkg{xparse}\cite{xparse}.
%     Specifically, \cs{Oops}\docoptd{\meta{object}} begins a series of instructions
%     alternating between `text' and definitions, that themselves optionally expand using predefined or inline rules.
%     For example,\begin{Verbatim}[breaklines=true]
%       \Oops<Math>[Let~]{Space=\Omega}*[~denote the sample space]{}
%     \end{Verbatim}
%     expands to: ``\Oops<Math>[Let~]{Space=\Omega}*[~denote the sample space]{}''.
%     As a side effect, |$\Space<Math>$| encodes``$\Space<Math>$''. \pkgparnamedefault~being the default for \meta{object}, it can be dropped.
%     Optionally, the definitions can be written to a file, and restored, which
%     can be useful for typesetting documents sharing the same notational conventions. Altogether, ``practical''. 
%   \end{abstract}
%   
%   \tableofcontents 
%   
%   \part{Usage}\label{part:usage}
%   \VerbatimFootnotes
%   
%   This part describes \label{impl:frontend}.
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}Convention}
%   \section*{Convention}%\label{usage:conv}
%   \begin{enumerate}
%   \item Loosely, those of \cite{interface3} and \cite{xparse}, for example as to the meaning of \meta{\doctl} and \docargnoval. 
%   \item If unspecified, the environment in which a function must be declared is \docenvdoc.
%   \item Where \meta{\pkgparname} is an optional argument, its default is \pkgparnamedefault.

%   \end{enumerate}
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}Loading the package}
%   
%   \begin{function}{\usepackage}
%     \begin{syntax}
%       \cs{usepackage}\doceval{\pkg{oops}}
%     \end{syntax}
%     \begin{description}
%     \item[Environment] \docU{\docenvpreamb}
%     \item[Requirement] \file{oops.sty} is in the path of the \LaTeX~engine. See \autoref{part:other}, \autoref{other:support}.
%     \end{description}  
%   \end{function}
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}\cs{Oops}}
%   \setcounter{subsection}{0}
%   \begin{function}{\Oops}
%     \begin{syntax}
%       \cs{Oops}\docoptd{\meta{\pkgparname}}
%       \docopto{\meta{\pkgparhead}}
%       \docopte{i}{\meta{\pkgparinneri}}
%       \Arg{\pkgpardefi}
%       |*|
%       \docopte{s}{\pkgpars}
%       \docopte{o}{\meta{\pkgparouter}}
%       \docopto{\meta{\pkgpartail}}
%     \end{syntax}
%     \begin{description}
%     \item[Requirement] \meta{\pkgpardefi} is mandatory.
%     \end{description}
%   \end{function}
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docoptd{\meta{\pkgparname}}}
%   \DescribeOption{\meta{\pkgparname}}
%   
%   \begin{description}
%   \item[Example] \pkgparnamedefault, |ModelA|, |ModelB|
%   \item[Semantics] Registers a new object, if applicable
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docopto{\meta{\pkgparhead}}}
%   \DescribeOption{\meta{\pkgparhead}}
%   
%   \begin{description}
%   \item[Example]|Let~|
%   \item[Semantics] Expands~\meta{\pkgparhead}
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docopte{i}{\meta{\pkgparinneri}}}
%   \DescribeOption{\meta{\pkgparinneri}}
%   
%   \begin{description}
%   \item[Example] |\mathbb{#1}|
%   \item[Semantics]
%     \begin{enumerate}
%     \item \docassign{\meta{val_{i} } }
%       { \meta{\pkgparinneri} applied to \meta{val_{i} } }
%     \end{enumerate}
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\Arg{\pkgpardefi}}
%   \DescribeOption{\meta{\pkgpardefi}}\label{par:defi}
%   
%   \begin{description}
%   \item[Example] |Elems={\omega_1, \dots, \omega_n}, Sample=\Omega|
%   \item[Semantics]
%     \begin{enumerate}
%       \setcounter{enumi}{1}
%     \item \docassign{ \cs{\meta{key_{i}}}\docoptd{\meta{\pkgparname}} }{\meta{val_i}} defined in 1.
%     \item If \pkgkeywr$=$\cs{BooleanTrue}, writes the definitions made in 2. to file \file{oops}\meta{digits}\file{.tex},\\
%       where \meta{digits}=|\pdfdate|
%     \end{enumerate}
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}*}
%   \DescribeOption{*}
%   
%   \begin{description}
%   \item[Semantics]
%     \begin{enumerate}
%       \setcounter{enumi}{3}
%     \item Expands~\meta{\pkgparouter} applied to the list created in 1., using \pkgpars~as separator.
%     \end{enumerate}
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docopte{s}{\pkgpars}}
%   
%   \DescribeOption{\meta{\pkgparsi}}
%   
%   \begin{description}
%   \item[Example] |{~\&~}|
%   \end{description}
%   
%   \DescribeOption{\meta{\pkgparsii}}
%   
%   \begin{description}
%   \item[Example] |{,~}|
%   \end{description}
%   \DescribeOption{\meta{\pkgparsiii}}
%   
%   \begin{description}
%   \item[Example] |{~\&~}|
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docopte{o}{\meta{\pkgparouter}}}
%   \DescribeOption{\meta{\pkgparouter}}
%   
%   \begin{description}
%   \item[Example] |$\left\{#1\right\}$| 
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \phantomsection\addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\docopto{\meta{\pkgpartail}}}
%   \DescribeOption{\meta{\pkgpartail}}
%   \begin{description}
%   \item[Semantics]
%     \cs{Oops}\docoptd{\meta{\pkgparname}}\docopto{\meta{\pkgpartail}}
%   \end{description}
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}\cs{OopsClear}}
%   \begin{function}{\OopsClear}
%     \begin{syntax}
%       \cs{OopsClear}\docoptd{\meta{\dockvl}}
%     \end{syntax}
%     \begin{description}
%     \item[Semantics] Clears any data created by \cs{Oops}\Arg{\pkgparname}, for all \meta{\pkgparname} in \meta{\dockvl}
%     \end{description}
%   \end{function}
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}\cs{OopsOption}}
%   \begin{function}{\OopsOption}
%     \begin{syntax}
%       \cs{OopsOption}\Arg{\pkgoptions}
%     \end{syntax} 
%     \begin{description}
%     \item[Semantics] Set default options for \cs{Oops}
%     \end{description}  
%   \end{function}
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\pkgkeyin}
%   \DescribeOption{\pkgkeyin}
%   \begin{description}
%   \item[Semantics] \docU{\docdefaultfor}\meta{\pkgparinneri}
%   \item[Syntax] Use |####1| as the argument to be replaced
%   \end{description} 
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\pkgkeyna}
%   \DescribeOption{\pkgkeyna}
%   \begin{description}
%   \item[Semantics] \docU{\docdefaultfor}\meta{\pkgparname}
%   \end{description} 
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\pkgkeyou}
%   \DescribeOption{Outer}
%   \begin{description}
%   \item[Semantics] \docU{\docdefaultfor}\meta{\pkgparouter}
%   \item[Syntax] Use |####1| as the argument to be replaced
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\pkgkeyse}
%   \DescribeOption{\pkgkeyse}
%   \begin{description}
%   \item[Semantics] \docU{\docdefaultfor}\pkgpars
%   \item[Syntax] That of `separators' in \cite[Section 8 of \pkg{l3seq}]{interface3}
%   \end{description}
%   
%   \addtocounter{subsection}{1}
%   \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}\pkgkeywr}
%   \DescribeOption{\pkgkeywr}
%   \begin{description}
%   \item[Syntax] \meta{\docbool}
%   \end{description}
%   
%   \addtocounter{section}{1}
%   \addcontentsline{toc}{section}{\protect\numberline{\thesection}\cs{OopsRead}}
%   \begin{function}{\OopsRead}
%     \begin{syntax}
%       \cs{OopsRead}\docopto{\meta{\docpath}}
%     \end{syntax} 
%     \begin{description}
%     \item[Semantics] \begin{enumerate}
%       \item Reads the definitions in \meta{\docpath}.
%       \item Writes to \file{oops.log}: `read from \meta{\docpath}'
%       \end{enumerate}
%     \item[Other] The default for \meta{\docpath} is the last write-file (see \meta{\pkgpardefi})
%     \end{description}  
%   \end{function}
%   
%   \clearpage
%   \part{Listing}\label{part:listing}
%   
%   \newtcblisting[auto counter]
%   {listing}[2][]{
%   noparskip,
%   breakable,
%   colback=white,
%   colframe=black,
%   opacitybacktitle=.8,%
%   fonttitle=\bfseries,
%   title=Listing~\thetcbcounter. #1,
%   arc=0pt,
%   outer arc=0pt,
%   boxrule=1pt,
%   ^^Atext only, ^^A% only for bech.tex
%   #2
% }
%   ^^A\pagestyle{empty} ^^A% only for bench.tex
%   
%   \docwarn To reproduce the listings in a \LaTeX~document,
%   use the same formatting instructions as those of the documentation portion of \file{oops.dtx}
%   (such as \cs{documentclass}, \cs{usepackage}, and \cs{newtcblisting}), and remove any |^||^A|.
%   Any deviation from the original may require tinkering.\footnote{For instance, in testing \docvers{1}{1},
%   I realized |\usepackage[T1]{fontenc}| was needed,
%   to work with |\documentclass{article}| in place of |\documentclass[full]{l3doc}|,
%   hence added it to the documentation portion of \file{oops.dtx}}
%   
%   ^^A% Inner={\{####1\}}, ^^A% Hook 1.a
%   ^^A%  Inner={\char`{####1\char`}}, ^^A% Hook 1.b
%   \phantomsection\addcontentsline{toc}{section}{\doclist{test:i}.}
%   \begin{listing}[]
%     {label=listing:test:i}
%     \OopsOption{
%     Inner={\char`{####1\char`}},
%     ^^A% spaces betw. inner and outer brackets matter!->
%     Separ={{\ \char`@\ }{\%\ }{\ \char`@\ }}, 
%     Outer={\char`^####1\$}}
%     \Oops<Test>{ X =x, Y = y, Z = z }*
%     \tab \X<Test>\Y<Test>\Z<Test>\\
%     \Oops<Test>i{(#1)}{ X = x, Y = y, Z = z }*
%     \tab \X<Test>\Y<Test>\Z<Test>\\
%     \Oops<Test>{ X = x, Y = y, Z = z }*s{{\ \&\ }{,\ }{\ \&\ }}
%     \tab \X<Test>\Y<Test>\Z<Test>\\
%     \OopsOption{ Write = \BooleanTrue }
%     \Oops<Test>{ X = x, Y = y, Z = z }*o{\char`[#1\char`]}
%     \tab \X<Test>\Y<Test>\Z<Test>\\
%     \OopsClear<Test>
%     \OopsOption{ Write = \BooleanFalse }
%   \end{listing}
%   ^^A \OopsRead \tab \X<Test>\Y<Test>\Z<Test> ^^A% Hool 1.c (FAIL with 1.a)
%   \phantomsection\addcontentsline{toc}{section}{\doclist{test:ii}.}
%   \begin{listing}[]
%     {label=listing:test:ii}
%     \OopsRead \tab \X<Test>\Y<Test>\Z<Test>
%     \OopsClear<Test>
%   \end{listing}
%   
%   \phantomsection\addcontentsline{toc}{section}{\doclist{proba:i}.}
%   \begin{listing}[]
%     {label=listing:proba:i}
%     \Oops[We call~]{Elems={\omega_1, \dots, \omega_n}}*
%     [~the elementary events, and ]{Space=\Omega}
%     [\begin{equation*}\Space=(\Elems)\end{equation*}~the sample space.]
%     {}
%     \OopsClear
%   \end{listing}
%   
%   \phantomsection\addcontentsline{toc}{section}{\doclist{proba:ii}.}
%   \begin{listing}[]
%     {label=listing:proba:ii}
%     \OopsOption{ Write = \BooleanTrue }
%     \Oops[Let ]
%     {Space=\Omega, SigmaField=\mathcal{F}, Measure=\mathcal{P}}
%     *s{{,}{,}{,}}o{\ensuremath{\{#1\}}}
%     [~denote the probability space, where $\SigmaField\subset 2^{\Space}$.]
%     {}
%     \OopsClear
%     \OopsOption{ Write = \BooleanFalse }
%   \end{listing}
%   
%   \phantomsection\addcontentsline{toc}{section}{\doclist{proba:iii}.}
%   \begin{listing}[]
%     {label=listing:proba:iii}
%     \OopsRead \tab $\Omega$ $\SigmaField$ $\Measure$
%     \OopsClear
%   \end{listing}
%   
%   ^^A%{OffeneMenge={D}, Ci={C^{1}}, Strecke={[x_0,x]}} ^^A% Hook 2.a
%   ^^A%Strecke={\char`[x_0,x\char`]}  % PASS % Hook 2.b
%   ^^A%Strecke={\[x_0,x\]}            % FAIL % Hook 2.c
%   \phantomsection\addcontentsline{toc}{section}{\doclist{mvt:i}.}
%   \begin{listing}[]{label=listing:mvt:i}
%     \OopsOption{ Write = \BooleanTrue }
%     \newtheorem{theorem}{Theorem}
%     \Oops i{\mathbb{#1}}
%     { N = { N } , R = { R }, Grad = { \operatorname{grad} } }
%     [\begin{theorem}
%       [Mittelwertsatz f\"ur $n$ Variable]Es~sei~]
%       { OffMenge = {D}, Ci = {C^{1}}, Strecke = {[x_0,x]} }
%       [$n\in\N$,~$\OffMenge\subseteq\N^n$ eine offene Menge und $f\in\Ci(\OffMenge,\R)$.
%       Dann gibt es auf jeder Strecke $\Strecke\subset\OffMenge$ einen Punkt $\xi\in\Strecke$,~]
%       { yD = { f(x)-f(x_0) }, xD = { x-x_0 }, Steig = { \frac{\yD}{\xD} } }
%       [so dass gilt
%       \begin{equation*}
%         \Steig = \Grad f(\xi)^{\top}
%       \end{equation*}
%     \end{theorem}]
%     {}
%     \OopsClear
%     \OopsOption{ Write = \BooleanFalse }
%   \end{listing}
%   
%   \phantomsection\addcontentsline{toc}{section}{\doclist{mvt:ii}.}
%   \begin{listing}[]
%     {label=listing:mvt:ii}
%     \OopsRead \tab $\N$ $\R$ $\OffMenge$ $\Ci$ $\Strecke$ 
%   \end{listing}
%   
%   ^^A   \StopEventually{^^A
%   ^^A   \PrintChanges
%   ^^A   \PrintIndex
%   ^^A }
%   \clearpage
%   \part{Other}\label{part:other}
%   
%   \section{Acknowledgment}\label{other:acknowl} 
%   
%   This work has benefited from Q\&A's from the \LaTeX community, see here: \url{https://tex.stackexchange.com/users/112708/erwann?tab=questions}.
%   Specific references are made in \autoref{part:impl}.
%   \doclist{proba:i} and \doclist{proba:ii} are from \cite{shir95}.
%   \doclist{mvt:i} is from \pkg{tcolbox}\cite[17.3]{tcolbox}.
%   
%   \section{Issues}\label{other:bug}
%   
%   \begin{enumerate}
%   \item \begin{description}
%       \docwarninp |Inner={\{####1\}|
%       \docwarnsymp \cs{OopsRead} fails
%       \docwarnfix |Inner={\char`{####1\char`}}|
%       \docwarnsee \doclist{test:i}
%     \end{description}
%   \item \begin{description}
%       \docwarninp Inside \meta{\pkgpardefi}, |{\[a,b\]}|
%       \docwarnfix |{[a,b]}| or |{\char`[a, b\char`]}|
%       \docwarnsee \doclist{mvt:i}
%     \end{description}
%   \item \begin{description}
%       \docwarninp Inside \meta{\pkgparhead},  |{[a, b)}| 
%       \docwarnfix |{{[}a, b{)}}|
%     \end{description}
%   \item \begin{description}
%       \docwarninp Inside \meta{\pkgparhead}, |\cal F| 
%       \docwarnfix |\mathcal{F}|
%     \end{description}
%   \end{enumerate}
%   
%   \section{Install}\label{other:install}
%   
%   Compiling \file{oops.dtx} (under Unix, |$tex oops.dtx|) will generate \file{oops.sty} and \file{oops.pdf}
%   
%   \section{Support}\label{other:support}
%   
%   This package is available from \url{https://www.ctan.org/pkg/oops} and \url{https://github.com/rogard/oops}.
%   
%   
%   \section{Unit testing}\label{other:ut}
%   
%   It's not possible to check the expansion of a certain class of macros against predefined values\cite{534100}. 
%   Instead, one can check that \autoref{part:listing},
%   as generated in \autoref{other:install} on one's own machine,
%   agrees with \file{bench.pdf} available at \url{https://github.com/rogard/oops},
%   
%   \begin{thebibliography}{1}
%   \bibitem{shir95} A.N. Shiryaev  {\em Probability} Springer, 1995
%   \bibitem{interface3} The \LaTeX3 Project Team {\em The \LaTeX3 interfaces} 
%     \url{http://ftp.math.purdue.edu/mirrors/ctan.org/macros/latex/contrib/l3kernel/interface3.pdf}
%   \bibitem{xparse} The \LaTeX3 Project Team {\em The \pkg{xparse} package} 
%     \url{http://ftp.math.purdue.edu/mirrors/ctan.org/macros/latex/contrib/l3packages/xparse.pdf}
%     ^^A\bibitem{l3buil} The \LaTeX3 Project Team {\em The \pkg{l3build} package} 
%     ^^A  \url{http://ftp.math.purdue.edu/mirrors/ctan.org/macros/latex/contrib/l3build/l3build.pdf}
%   \bibitem{tcolbox} Thomas F. Sturm {\em The \pkg{tcolorbox} package} 
%     \url{http://www.texdoc.net/texmf-dist/doc/latex/tcolorbox/tcolorbox.pdf}
%   \bibitem{534100} \url{https://tex.stackexchange.com/a/534100/112708}
%   \end{thebibliography}
%   
%   \changes{\docvers{1}{0}}{2020/03/08}{Initial version}
%   \changes{\docvers{1}{1}}{2020/04/04}{Revamped: much of the implementation}
%   \changes{\docvers{1}{1}}{2020/04/04}{Replaced: \Arg{\pkgpardefii}~by~\docoptd{\pkgpardefii}~given that option type \texttt{G} not recommended\cite{xparse}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Replaced: \cs{OopsOptions}~by~\cs{OopsOption}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Replaced: \docarg{GenericObject} by~\docarg{Name}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Replaced: \docarg{Separators}~by~\docarg{Separ}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Added:\cs{OopsTest}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Added:\cs{OopsRestore}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Added: \docarg{Save}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Deleted: Listing 1-5 from \docvers{1}{0}}
%   \changes{\docvers{1}{1}}{2020/04/04}{Added: Listing~1., 2., 3., 4., 6., and 9.}
%   \changes{\docvers{1}{1}}{2020/04/04}{Fixed: apparent anomaly in \docvers{1}{0}'s Listing~4, see \doclist{test:i}}
%   \changes{\docvers{1}{2}}{2020/04/06}{Added: optional star to \cs{OopsNew} as instruction to expand \pkgpardefi}
%   \changes{\docvers{1}{2}}{2020/04/06}{Replaced: \cs{OopsClear}\Arg{\pkgparname} by \cs{OopsClear}\docopto{\meta{\dockvl}}}
%   \changes{\docvers{1}{2}}{2020/04/06}{Deleted: \pkgpardefii~and~\pkgparinnerii}
%   \changes{\docvers{1}{2}}{2020/04/06}{Deleted: \cs{OopsTest}}
%   \changes{\docvers{1}{2}}{2020/04/06}{Deleted: Listing~2-3 from \docvers{1}{1}.}
%   \changes{\docvers{1}{2}}{2020/04/06}{Replaced: \cs{Save} by \cs{Write}}
%   \changes{\docvers{1}{2}}{2020/04/06}{Replaced: \cs{Restore} by \cs{Read}}
%   \changes{\docvers{1}{3}}{2020/04/06}{Replaced: \cs{OopsNew} by \cs{Oops}}
%   \changes{\docvers{1}{3}}{2020/04/06}{Replaced: \Arg{\pkgparname} and \docopto{\meta{\pkgparname}} by \docoptd{\meta{\pkgparname}} }
%   
%   \clearpage
%   \PrintChanges
%   \PrintIndex
%   \part{Implementation}\label{part:impl}
%   \StopEventually{}
%   \begin{implementation}
%     
%     \iffalse
%<*package>     
%     \fi
%    \begin{macrocode}
%<@@=oops>      
\NeedsTeXFormat{LaTeX2e}[2019/10/01]
\ExplSyntaxOn
%    \end{macrocode}
% \section{\texttt{aux}}
% \begin{macro}{\@@_aux_inner_set:n}
%   \begin{arguments}
%   \item \meta{code}
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_inner_set:n
{
  \cs_gset:Npn \@@_aux_inner:n ##1 { #1 }
  \cs_generate_variant:Nn \@@_aux_inner:n { e }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_key:w }
%   \begin{arguments}
%   \item \meta{ key }
%   \item \meta{ value }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_aux_key:w #1 = #2 \q_stop
{
  \seq_gput_right:Nx \g@@_aux_key_seq { \tl_trim_spaces:n{ #1 } }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_key:n }
%   \begin{arguments}
%   \item \meta{ key = value }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_key:n
{
  \@@_aux_key:w #1 \q_stop
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_key:N }
%   \begin{arguments}
%   \item \meta{ seq }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_key:N 
{
  \seq_gclear_new:N \g@@_aux_key_seq
  \seq_map_function:NN #1 \@@_aux_key:n
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_outer_set:n}
%   \begin{arguments}
%   \item \meta{ inline code }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_outer_set:n
{
  \cs_gset:Npn \@@_aux_outer:n ##1 { #1 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_prop:w}
%   \begin{arguments}
%   \item \meta{ key }
%   \item \meta{ value }
%   \end{arguments}
%    \begin{macrocode}
\prop_new:N \g@@_aux_prop
\cs_new_protected:Nn \@@_aux_prop:nn 
{
  \prop_gput:Nnn \g@@_aux_prop{ #1 } { #2 }
}
\cs_generate_variant:Nn \@@_aux_prop:nn { eo }
\cs_new_protected:Npn \@@_aux_prop:w #1 = #2 \q_stop
{
  \@@_aux_prop:eo
  { \tl_trim_spaces:n{ #1 } }
  { \@@_aux_inner:e{ \tl_trim_spaces:n{ #2 } } }
% ^^A\prop_gput:Noo \g@@_aux_prop % v1.1, FAIL with N = N (OK with N= N)
% ^^A  { \tl_trim_spaces:n{ #1 } } { \@@_aux_inner:n{ #2 } }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_prop:n}
%   \begin{arguments}
%   \item \meta{ key = value }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_prop:n
{
  \@@_aux_prop:w #1 \q_stop 
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_prop:N}
%   \begin{arguments}
%   \item \meta{\dockvl}
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_prop:N
{
  \prop_gclear_new:N \g@@_aux_prop
  \seq_if_empty:NTF #1
  { \c_empty_tl }
  {
    \seq_map_function:NN #1 \@@_aux_prop:n
  }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_aux_val:Nn}
%   \begin{arguments}
%   \item \meta{ seq }
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_aux_val:Nn
{
  \seq_gclear_new:N \@@_aux_val
  \@@_seq_from_prop:NNn \@@_aux_val #1 { \@@_prop_name:n{ #2 } } 
}
%    \end{macrocode}
% \end{macro}
% \section{\texttt{log}}
% \begin{macro}{\@@_log_close:}
%    \begin{macrocode}
\iow_new:N \g@@_log_iow
\AtEndDocument{\iow_close:N \g@@_log_iow}
\bool_set_false:N \g@@_log_open_bool
\cs_new_protected:Nn \@@_log_close:
{
  \iow_close:N \g@@_log_iow
  \bool_gset_false:N \g@@_log_open_bool
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_log_open:}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_log_open:
{
  \tl_gset:Nx \g@@_log_to_tl{oops\pdfdate}
  \iow_open:Nn \g@@_log_iow {\g@@_log_to_tl}
  \bool_gset_true:N \g@@_log_open_bool
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_log_read:n}
%   \begin{arguments}
%   \item \meta{\docpath}
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_log_read:n
{
  \file_input:n{#1}
  \tl_log:n{read~from~#1}
}
\cs_generate_variant:Nn \@@_log_read:n { e }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_log_read:}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_log_read:
{
  \@@_log_read:e{\g@@_log_to_tl}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_log_write:n}
%    \begin{macrocode}
\tl_new:N \g@@_log_to_tl
\cs_new_protected:Nn \@@_log_write:n
{
  \bool_if:nTF{ \g@@_log_open_bool }
  {
    \iow_now:Nn \g@@_log_iow { #1 }
    \tl_log:n{ write~to~#1 }
  }
  { \msg_error:nnn{ @@ }{ iow }{ \g@@_log_iow }  }
}
\cs_generate_variant:Nn \@@_log_write:n { e }
%    \end{macrocode}
% \end{macro}
% \section{\texttt{make}}
% \begin{macro}{\@@_make_key:Nn}
%   \begin{arguments}
%   \item \meta{ token }
%   \item \meta{ key }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_make_key:Nn 
{
  \exp_args:NNx
  \ProvideDocumentCommand{ #1 } 
  { D<>{\g@@_option_name_tl} }
  {
    \@@_prop_item:nn{ ##1 }{ #2 }
  }
}
\cs_generate_variant:Nn \@@_make_key:Nn {c}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_make_key:n}
%   \begin{arguments}
%   \item \meta{ key }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_make_key:n
{
  \@@_make_key:cn{#1}{#1}
}
\cs_generate_variant:Nn \@@_make_key:n { e }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_make_key:N}
%   \begin{arguments}
%   \item \meta{ seq }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_make_key:N
{
  \seq_map_function:NN #1 \@@_make_key:e
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_make_new:nnnn}
%   \begin{arguments}
%   \item \meta{ token list }
%   \item \meta{ seq_{1} }
%   \item \meta{ seq_{2} } 
%   \item \meta{ prop }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_make_new:nnnn #1 #2 #3 #4
{
  \exp_args:NNx \DeclareDocumentCommand \Oops
  { D<>{#1} +o E{ i }{ { #2 } } m s E{ s o }{ { #3 }{ #4 } } +o }
  {
    \@@_prop_if_exist:nTF{ ##1 }
    { \c_empty_tl }
    { \@@_prop_new:n{ ##1 } }
    \exp_args:No \@@_aux_inner_set:n{ ##3 }
    \seq_set_from_clist:Nn \g@@_aux_keyval_seq { ##4 }
    \@@_aux_prop:N \g@@_aux_keyval_seq
    \@@_prop_append:Nn \g@@_aux_prop { ##1 }
    \@@_aux_key:N \g@@_aux_keyval_seq
    \@@_make_key:N \g@@_aux_key_seq
    \bool_if:nTF{ \g@@_log_open_bool }
    {%^^A https://tex.stackexchange.com/questions/536597
      \@@_log_write:n
      {
        \begingroup \def \@@_log_entry { \Oops< ##1 >i{##3}{ ##4 } } \expandafter \endgroup \@@_log_entry      
      }
    }{\c_empty_tl}
    \IfValueT{ ##2 }{ ##2 }
    \IfBooleanT{ ##5 }
    {
      \@@_aux_val:Nn \g@@_aux_key_seq { ##1 }
      \@@_aux_outer_set:n{ ##7 }
      \@@_aux_outer:n
      { 
        \exp_last_unbraced:NNo
        \seq_use:Nnnn
        \@@_aux_val
        { ##6 }
      }
    }
    \IfValueT{ ##8 }
    {
      \exp_not:n{ \Oops< ##1 >[ ##8 ] }
    }
  }
}
%    \end{macrocode}
% \end{macro}
% \section{\texttt{msg}}
%    \begin{macrocode}
\msg_new:nnn {@@}{ generic }{ #1 }
\msg_new:nnn {@@}{ iow }{ #1~is~closed~can't~write }
\msg_new:nnn {@@}{ keyonly }{ #1~does~not~take~values;~keyval~is~#2 }
\msg_new:nnn {@@}{ keywrong }{ #1~does~not~recognize~key~#2 }
\msg_new:nnn {@@}{ unset }{ #1~unset }
%    \end{macrocode}
% \section{\texttt{option}}
% \begin{macro}{\@@_aux_inner:n}
%   \begin{arguments}
%   \item \meta{code}
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_option_inner:n
{
  \tl_gset:Nn \g@@_option_inner_tl { #1 }
}
\@@_option_inner:n
{
  \msg_warning:nnn{ @@ }{ unset }{ \exp_not:N \g@@_option_inner_tl }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_option_name:n}
%   \begin{arguments}
%   \item \meta{\doctl}
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_option_name:n
{
  \tl_gset:Nn \g@@_option_name_tl{ #1 }
}
\@@_option_name:n
{  
  \msg_error:nnx{ @@ }
  { generic }
  { \exp_not:N\g@@_option_name_tl~undefined }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_option_outer:n}
%   \begin{arguments}
%   \item \meta{ inline code }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_option_outer:n
{
  \tl_gset:Nn \g@@_option_outer_tl { #1 }
}
\@@_option_outer:n
{
  \msg_warning:nnn{ @@ }{ unset }{ \exp_not:N \g@@_option_outer_tl }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_option_separ:n}
%   \begin{arguments}
%   \item \Arg{ \doctl_{1} }\Arg{ \doctl_{2} }\Arg{ \doctl_{3} }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_option_separ:n
{
  \cs_gset:Npn \g@@_option_separ_tl { #1 }
}
\@@_option_separ:n
{
  \msg_warning:nnn{ @@ }{ unset }{ \exp_not:N \g@@_option_separ_tl }
}
%    \end{macrocode}
% \end{macro}
% \section{\texttt{prop}}
% \begin{macro}{\@@_prop_append:NN,\@@_prop_append:cN}
%   \begin{arguments}
%   \item \meta{ prop_{1} }
%   \item \meta{ prop_{2} }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_append:NN #1 #2
{
  \cs_set:Nn \@@_prop_append:nn
  {
    \prop_gput:Nnx #1 { ##1 }{ \prop_item:Nn #2{ ##1 } }
  }
  \prop_map_function:NN #2 \@@_prop_append:nn
}
\cs_generate_variant:Nn \@@_prop_append:NN { cN }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_append:Nn}
%   \begin{arguments}
%   \item \meta{ prop }
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_prop_append:Nn 
{
  \@@_prop_append:cN{ \@@_prop_name:n { #2 } } #1
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_clear_new:n}
%   \begin{arguments}
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_prop_clear_new:n
{
  \exp_args:No \prop_clear_new:c{ \@@_prop_name:n { #1 } }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_clear_new_map:n}
%   \begin{arguments}
%   \item \meta{ keyval list }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_prop_clear_new_map:n
{
  \seq_set_from_clist:Nn \g@@_aux_key_seq { #1 }
  \seq_map_function:NN \g@@_aux_key_seq \@@_prop_clear_new:n
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_if_exist:nTF}
%   \begin{arguments}
%   \item \meta{\doctl_{1}}
%   \item \meta{\doctl_{2}}
%   \item \meta{\doctl_{3}}
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_prop_if_exist:nTF 
{
  \prop_if_exist:cTF{ \@@_prop_name:n { #1 } }{ #2 }{ #3 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_item:nn}
%   \begin{arguments}
%   \item \meta{ tl var name }
%   \item \meta{ key }
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_prop_item:nn
{
  \prop_item:cn { \@@_prop_name:n { #1 } } { #2 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_name:n}
%   \begin{arguments}
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Npn \@@_prop_name:n #1{ @@_#1 }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prop_new:n}
%   \begin{arguments}
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_prop_new:n 
{
  \prop_new:c{ \@@_prop_name:n { #1 } }
}
%    \end{macrocode}
% \end{macro}
% \section{\texttt{seq}}
% \begin{macro}{\@@_seq_from_prop:NNn}
%   \begin{arguments}
%   \item \meta{ seq_{1} }
%   \item \meta{ seq_{2} } (keys)
%   \item \meta{ prop }
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_seq_from_prop:NNn
{
  \cs_set_protected:Nn \@@_seq_from_prop:n
  {
    \seq_gput_right:No #1 { \prop_item:cn{ #3 }{ ##1 } }
  }
  \seq_map_function:NN #2 \@@_seq_from_prop:n
}
%    \end{macrocode}
% \end{macro}
% \section{Front-end}\label{impl:frontend}
%    \begin{macrocode}
\keys_define:nn { @@ }
{
  Name .code:n={
% ^^A    \@@_aux_name:n{ #1 }
\@@_option_name:n{ #1 }
\exp_last_unbraced:Nf 
\@@_make_new:nnnn
{
  { \g@@_option_name_tl }
  { \g@@_option_inner_tl }
  { \g@@_option_separ_tl }
  { \g@@_option_outer_tl }
}
},
Name .value_required:n = false,
Name .default:n = { Math },
Name .initial:n = { Math },
Inner .code:n={
  \@@_option_inner:n{ #1 }
  \exp_last_unbraced:Nf 
  \@@_make_new:nnnn
  {
    { \g@@_option_name_tl }
    { \g@@_option_inner_tl }
    { \g@@_option_separ_tl }
    { \g@@_option_outer_tl }
  }
},
Inner .value_required:n = false,
Inner .default:n = { ####1 },
Inner .initial:n = { ####1 },
Outer .code:n={
  \@@_option_outer:n{ #1 }
  \exp_last_unbraced:Nf 
  \@@_make_new:nnnn
  {
    { \g@@_option_name_tl }
    { \g@@_option_inner_tl }
    { \g@@_option_separ_tl }
    { \g@@_option_outer_tl }
  }
},
Outer .value_required:n = false,
Outer .default:n = { \ensuremath{####1} },
Outer .initial:n = { \ensuremath{####1} },
Write .code:n = {
  \bool_if:nTF{#1}
  {\@@_log_open:}
  {\@@_log_close:}
},
Write .value_required:n = false,
Write .default:n = \BooleanFalse,
Write .initial:n = \BooleanFalse,
Separ .code:n={
  \@@_option_separ:n{ #1 }
  \exp_last_unbraced:Nf 
  \@@_make_new:nnnn
  {
    { \g@@_option_name_tl }
    { \g@@_option_inner_tl }
    { \g@@_option_separ_tl }
    { \g@@_option_outer_tl }
  }
},
Separ .value_required:n = false,
Separ .default:n = { { {\ }and{\ } } { ,{\ } } { ,{\ }and{\ } } },
Separ .initial:n = { { {\ }and{\ } } { ,{\ } } { ,{\ }and{\ } } }
}
%    \end{macrocode}
% \begin{macro}{\OopsClear}
%   \begin{arguments}
%   \item \meta{ tl var name }
%   \end{arguments}
%    \begin{macrocode}
\NewDocumentCommand{ \OopsClear }
{ D<>{\g@@_option_name_tl} }
{ 
  \@@_prop_clear_new_map:n{ #1 } 
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\OopsOption}
%    \begin{macrocode}
\NewDocumentCommand{ \OopsOption }
{ m }
{ 
  \keys_set:nn{ @@ }{ #1 } % TODO record
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\OopsRead}
%    \begin{macrocode}
\NewDocumentCommand{\OopsRead}
{o}
{
  \IfValueTF{#1}
  {\@@_log_read:e{#1}}
  {\@@_log_read:}
}
%    \end{macrocode}
% \end{macro}
% \section{Misc}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \end{implementation}
% 
% \iffalse
%</package> 
% \fi
% \Finale
\endinput